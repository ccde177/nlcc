use crate::lexer::{Token, Tokens};
use std::fmt;

type Identifier = String;

enum Program {
    FunDef(Function)
}

struct Function {
    name: Identifier,
    body: Statement,
}

enum Statement {
    Return(Expression)
}

enum Expression {
    Constant(u64)
}

enum ParseError {
    ExpectedButGot(Token, Token),
    ExpectedButGotNone(Token)
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ExpectedButGot(t1, t2) => write!(f, "Expected token of type {:?} but got {:?}", t1, t2),
            Self::ExpectedButGotNone(t) => write!(f, "Expected token of type {:?} but got None", t)
        }
    }
}

fn expect_token(tokens: &mut Tokens, token: Token) -> Result<(), ParseError> {
    tokens.pop().map_or(Err(ParseError::ExpectedButGotNone(token.clone())), |t| if t == token { 
        Ok(()) 
    } else { Err(ParseError::ExpectedButGot(t.clone(), token.clone())) } )
}

fn parse_function(tokens: &mut Tokens) -> Result<Function, ParseError> { 

}
fn parse_program(tokens: &mut Tokens) -> Result<Program, ParseError> {
    Ok(Program::FunDef(parse_function(tokens)?))
}
fn parse(mut tokens: Tokens) -> Result<Program, ParseError> {
    tokens.reverse();
    Ok(parse_program(&mut tokens)?)
}

